<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Blochin pallo demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <script src="/lib/math.min.js"></script>
    <script src="/math_support.js"></script>
    <script src="/ports.js"></script>
  </head>
  <body>
    <div id="info"></div>
    
    <div id="controls">
    </div>

    <script type="module">

      import * as THREE from '/lib/three.module.js';

      import { OrbitControls } from '/lib/OrbitControls.js';


      
      function registerPort(name) {
        var btn = document.createElement("button");
        btn.appendChild(document.createTextNode(name));
        btn.setAttribute("data-name", name);
        btn.addEventListener("mouseover", showPortAxis);
        btn.addEventListener("mouseout", hidePortAxis);
        btn.addEventListener("click", doPort);
        document.getElementById("controls").appendChild(btn);
      }

      var group, camera, scene, renderer, doDraw = true;
      var arrow, axisGroup;
      
      function requestDraw() { doDraw = true; }
      
      var qubitState = math.matrix([[1], [0]]);
      
      var animating = false;
      var animatingStarted, animatingAxis = new THREE.Vector3(), animatingAngle, animatingBaseState = new THREE.Vector3();
      var animatingBasisCRotation = 0;
      
      var showingPort = false;
      var showingPortAxis = new THREE.Vector3();
      
      var axisCumulativeRotation = 0;
      
      function showPortAxis(e) {
        var name = e.target.getAttribute("data-name");
        showingPort = true;
        showingPortAxis.set(...stateToBloch(ports[name].eigenvector));
        if (ports[name].rotation < 0) {
          showingPortAxis.negate();
        }
        requestDraw();
      }
      
      function hidePortAxis() {
        showingPort = false;
        requestDraw();
      }
      
      function doPort(e) {
        var name = e.target.getAttribute("data-name");
        animatingStarted = (new Date()).getTime();
        animatingAxis.set(...stateToBloch(ports[name].eigenvector));
        animatingAngle = ports[name].rotation;
        if (animatingAngle < 0) {
          animatingAngle *= -1;
          animatingAxis.negate();
        }
        animatingBaseState.set(...stateToBloch(qubitState));
        animatingBasisCRotation = axisCumulativeRotation;
        axisCumulativeRotation += animatingAngle;
        axisCumulativeRotation %= 2*Math.PI;
        qubitState = math.multiply(ports[name].mat, qubitState);
        updateInfo();
        animating = true;
      }
      
      function updateInfo() {
        var [[a], [b]] = qubitState._data;
        var text = 
        document.getElementById("info").innerHTML = math.format(qubitState, { notation: "fixed", precision: 2 });
      }
      
      for (var name in ports) {
        registerPort(name);
      }
      updateInfo();
      init3D();
      animate();
      
      function init3D() {
        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor(0xffffff, 1);
        document.body.appendChild( renderer.domElement );

        // camera

        camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( 15, 20, 30 );
        scene.add( camera );
        
        onWindowResize();

        // controls

        var orbit = new OrbitControls( camera, renderer.domElement );
        orbit.minDistance = 20;
        orbit.maxDistance = 50;
        orbit.maxPolarAngle = Math.PI / 2;
        orbit.enablePan = false;
        orbit.addEventListener('change', requestDraw);

        scene.add( new THREE.AmbientLight( 0x222222 ) );

        // light

        var light = new THREE.PointLight( 0xffffff, 1 );
        light.position.set(-50, 100, 50);
        scene.add( light );

        // helper

        scene.add( new THREE.AxesHelper( 12 ) );

        // textures

        var loader = new THREE.TextureLoader();
        var ket0t = loader.load('assets/ket 0.png', requestDraw);
        var ket1t = loader.load('assets/ket 1.png', requestDraw);
        var ket0m = new THREE.SpriteMaterial({ map: ket0t, alphaTest: 0.1, sizeAttenuation: false });
        var ket1m = new THREE.SpriteMaterial({ map: ket1t, alphaTest: 0.1, sizeAttenuation: false });
        var ket0s = new THREE.Sprite(ket0m);
        ket0s.renderOrder = 0;
        ket0s.position.set(0, 10, 0);
        ket0s.center.set(-0.5, -0.5);
        ket0s.scale.multiplyScalar(1/32);
        var ket1s = new THREE.Sprite(ket1m);
        ket1s.renderOrder = 0;
        ket1s.position.set(0, -10, 0);
        ket1s.center.set(-0.5, 1.5);
        ket1s.scale.multiplyScalar(1/32);
        scene.add(ket0s);
        scene.add(ket1s);

        group = new THREE.Group();
        scene.add(group);

        var meshMaterial = new THREE.MeshLambertMaterial( {
          color: 0xbbbbbb,
          opacity: 0.5,
          transparent: true
        } );

        var meshGeometry = new THREE.SphereGeometry(10, 64, 64);

        //var mesh = new THREE.Mesh( meshGeometry, meshMaterial );
        //mesh.material.side = THREE.BackSide; // back faces
        //mesh.renderOrder = 0;
        //group.add( mesh );

        var mesh = new THREE.Mesh( meshGeometry, meshMaterial.clone() );
        mesh.material.side = THREE.FrontSide;
        mesh.renderOrder = 1;
        group.add( mesh );
        
        
        var circleDashMaterial = new THREE.LineDashedMaterial({
          color: 0x000000,
          linewidth: 1,
          scale: 1,
          dashSize: 0.5,
          gapSize: 0.5,
        });
        var circle_dash_g = new THREE.CircleGeometry(10.01, 64);
        circle_dash_g.rotateX(Math.PI/2);
        circle_dash_g.vertices.shift();
        circle_dash_g.vertices.push(circle_dash_g.vertices[0]);
        var circle_dash = new THREE.Line(circle_dash_g, circleDashMaterial);
        circle_dash.computeLineDistances();
        scene.add(circle_dash);
        
        arrow = new THREE.ArrowHelper(new THREE.Vector3(...stateToBloch(qubitState)), new THREE.Vector3(0, 0, 0), 10, 0x000000, 1, 0.4);
        arrow.line.material.linewidth = 2;
        group.add(arrow);
        
        
        axisGroup = new THREE.Group();
        // axisGroup.matrixAutoUpdate = false;
        scene.add(axisGroup);
        
        var axisLineGeometry = new THREE.Geometry();
        axisLineGeometry.vertices.push(new THREE.Vector3(0, -12, 0), new THREE.Vector3(0, 12, 0));
        var axisLineMaterial = new THREE.LineDashedMaterial({
          color: 0xee0000,
          linewidth: 2,
          scale: 1,
          dashSize: 0.5,
          gapSize: 0.5,
        });
        var axisLine = new THREE.LineSegments(axisLineGeometry, axisLineMaterial);
        axisLine.computeLineDistances();
        axisGroup.add(axisLine);
        
        var axisIconGeometry = new THREE.PlaneGeometry(2, 2);
        var axisIconTexture = loader.load("/assets/rotate.png");
        var axisIconMaterial = new THREE.MeshBasicMaterial({ 
          alphaMap: axisIconTexture,
          alphaTest: 0.1,
          transparent: true,
          color: 0x000000,
          side: THREE.DoubleSide,
        });
        var axisIcon = new THREE.Mesh(axisIconGeometry, axisIconMaterial);
        axisIcon.renderOrder = 0;
        axisIcon.position.set(0, 5, 0);
        axisIcon.rotateX(-Math.PI/2);
        axisGroup.add(axisIcon);
        
        var sAxisIcon = axisIcon.clone();
        sAxisIcon.position.set(0, -5, 0);
        axisGroup.add(sAxisIcon);
        
        // axisArrow = new THREE.ArrowHelper(new THREE.Vector3(...stateToBloch(qubitState)), new THREE.Vector3(0, 0, 0), 15, 0x000000, 1, 0.4);
        // var axisMaterial = new THREE.LineDashedMaterial({
        //   color: 0x000000,
        //   linewidth: 1,
        //   scale: 1,
        //   dashSize: 0.5,
        //   gapSize: 0.5,
        // });
        // axisArrow.line.material = axisMaterial;
        // axisArrow.visible = false;
        // group.add(axisArrow);
        
        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {
        var width = window.innerWidth, height = window.innerHeight;
        width = Math.min(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        
        requestDraw();
      }

      function animate() {
        if (animating) {
          doDraw = true;
          var t = ((new Date()).getTime() - animatingStarted)/1000;
          if (t >= 1) {
            animating = false;
            arrow.setDirection(new THREE.Vector3(...stateToBloch(qubitState)));
          } else {
            rotateToVector(axisGroup, animatingAxis);
            axisGroup.rotateOnWorldAxis(animatingAxis, animatingBasisCRotation + animatingAngle*t);
            arrow.setDirection(animatingBaseState);
            arrow.rotateOnWorldAxis(animatingAxis, animatingAngle*t);
          }
        } else if (showingPort) {
          rotateToVector(axisGroup, showingPortAxis);
          axisGroup.rotateOnWorldAxis(showingPortAxis, axisCumulativeRotation);
        }
        axisGroup.visible = animating || showingPort;

        if (doDraw) render();
        doDraw = false;
        requestAnimationFrame( animate );

      }
      
      // Copied from ArrowHelper implementation
      var _axis = new THREE.Vector3();
      function rotateToVector(obj, dir) {
        if ( dir.y > 0.99999 ) {
          obj.quaternion.set( 0, 0, 0, 1 );
        } else if ( dir.y < - 0.99999 ) {
          obj.quaternion.set( 1, 0, 0, 0 );
        } else {
          _axis.set( dir.z, 0, - dir.x ).normalize();
          var radians = Math.acos( dir.y );
          obj.quaternion.setFromAxisAngle( _axis, radians );
        }
      }

      function render() {
        renderer.render( scene, camera );
      }

    </script>

  </body>
</html>
